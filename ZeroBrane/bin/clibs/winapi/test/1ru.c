//## ru 	 1.c
#вставить "utf8.h"

#вставить <stdio.h>
#вставить <assert.h>

/*
 * unidata.h - generated by parseucd.lua
 */
#еслинеопред unidata_h
#опред unidata_h

опредтип структура таблица_интервалов {
    беззнак целое первый;
    беззнак целое последний;
    целое шаг;
} таблица_интервалов;

опредтип структура conv_table {
    беззнак целое первый;
    беззнак целое последний;
    целое шаг;
    целое сдвиг;
} conv_table;



статик целое найти_в_интервалах(таблица_интервалов *t, size_t размер, беззнак юникод_символ) {
  size_t начало, конец;

  начало = 0;
  конец = размер;

  пока (начало < конец) {
    целое mid = (начало + конец) / 2;
    если (t[mid].последний < юникод_символ)
      начало = mid + 1;
    иначе если (t[mid].первый > юникод_символ)
      конец = mid;
    иначе
      возврат (юникод_символ - t[mid].первый) % t[mid].шаг == 0;
  }

  возврат 0;
}


статик структура таблица_интервалов t1_charset[] = {
	{ 32, 48, 16 },
	{ 49, 57, 1 },
	{ 95, 95, 1 },
};

статик структура таблица_интервалов l2_charset[] = {
	{ 1, 2, 1 },
	{ 2, 3, 1 },
	{ 3, 7, 4 },
	{ 55, 55, 1 },
};

#конецесли /* unidata_h */


целое входит_в_класс(беззнак юникод_символ, беззнак * множество){
	пока(*множество){
		если( *множество<=юникод_символ && *(множество+1)>=юникод_символ ) возврат 1;
		множество += 2;
	}
	множество++;
	пока(*множество){
		если( *множество==юникод_символ ) возврат 1;
		множество++;
	}
	возврат 0;
}

беззнак * нов_симв_класс(пост симв * с0, пост симв * скн){
	пост симв* с = с0;
	беззнак буффер[200], юникод_символ;
	size_t sh, sh1;
	sh = юник8_декоде(с, скн, &юникод_символ);

	возврат 0;
}

беззнак перв_ид[] = {1040,1103,'A','z', 0,95, 0};
беззнак след_ид[] = {1040,1103,'A','z',48,57, 0,95, 0};
беззнак цифра[] = {48,57, 0, 0};
беззнак пробелы[] = {0,10,13,9, 32, 0};
беззнак плюс_и_минус[] = {0,'+','-', 0};

структура правило;
опредтип структура регвыраж{
	объединение {
		беззнак * множество;
		беззнак юникод_символ;
		структура регвыраж * ре;
		структура регвыраж ** результат;
	};
	симв тип:4;
	симв соотв_повтор:3;
} регвыраж;


пост симв* соотв_регвыраж(пост симв* с0, пост симв* скн, регвыраж* ре);
пост симв* соотв_алтерн(пост симв* с, пост симв* скн, структура регвыраж** правила);
пост симв* соотв_сбаланс(пост симв* с, пост симв* скн, регвыраж** правила);


пост симв* соотв_регвыраж(пост симв* с0, пост симв* скн, регвыраж* ре){
	#	опред след_елем_регвыраж { ре++; ре_индекс++; }
	если(!ре) возврат NULL; утверждение(ре);
	пост симв* с = с0;
	пост симв* с1;
	пост симв* с2;
	беззнак юникод_символ;
	целое ре_индекс = 0;
	целое есть_совпадение = 0;
	целое счетчик_повторений = 0;
	size_t sh, sh1;
	sh = юник8_декоде(с, скн, &юникод_символ);
	пока((ре)->тип){
		если(!юникод_символ || !sh) {
			есть_совпадение = 0;
		}иначе{
			выбор (ре->тип) {
			  при 1: есть_совпадение = ре->юникод_символ==юникод_символ; стоп;
			  при 2: есть_совпадение = входит_в_класс(юникод_символ, ре->множество); стоп;
			  при 3: с2 = соотв_алтерн(с, скн, ре->результат);
			  	есть_совпадение = с2>с;
			  	если( есть_совпадение ) sh = с2-с;
					стоп;
			  при 4: с2 = соотв_регвыраж(с, скн, ре->ре);
			  	есть_совпадение = с2>с;
			  	если( есть_совпадение ) sh = с2-с;
			  	стоп;
			  поумолчанию : печатьф("unknown expr type %3d in re %p:%3d\n", ре->тип, ре, ре_индекс); exit(5); стоп;
			}
		}
		если(ре->соотв_повтор&0x4) есть_совпадение = !есть_совпадение;
		если( есть_совпадение ){
			с += sh;
			sh = юник8_декоде(с, скн, &юникод_символ);
			если(!(ре->соотв_повтор&0x1)) след_елем_регвыраж иначе{ счетчик_повторений++; }
		}иначе{
			если(((ре->соотв_повтор&0x1) && счетчик_повторений) ||
				(ре->соотв_повтор&0x2)){
				счетчик_повторений = 0;
				след_елем_регвыраж; //s += sh;
				если(!юникод_символ || !sh){ стоп; }иначе{ продолжить;}
			}
			возврат NULL;
		}
	}
	возврат с;
	#разопред след_елем_регвыраж
}

опредтип структура правило{
	пост симв имя[20];
  регвыраж *ре;
} правило;

пост симв* соотв_алтерн(пост симв* с, пост симв* скн, регвыраж** правила){
	пост симв* с1 = NULL;
	целое ри;
	для(; правила; правила++){
		с1 = соотв_регвыраж(с, скн, *правила);
		// printf("\ttoken %s\t%d\n", rules[ri].name, s1);
		если(с1) возврат с1;
	}
	возврат NULL;
}

пост симв* соотв_сбаланс(пост симв* с0, пост симв* скн, регвыраж** правила){
	беззнак юникод_символ;
	регвыраж* open = *правила; //rules++;
	регвыраж* close = 0;//*rules ? *(rules) : open;
	регвыраж* esc = 0;//*rules ? *rules : NULL;
	печатьф("%p\t%p\t%p\n", open, close, esc);
	пост симв* с = с0;
	пост симв* с1 = соотв_регвыраж(с, скн, open);
	печатьф("\t%p\t%p\t%p\n", с, с1, с0);
	целое b = 1;
	пока (с1 && с1<=скн && с1>с){
		печатьф("\t\t%p\t%p\t%p\n", с, с1, с0);
		с = с1;
		если(!с) стоп;
		с1 = соотв_регвыраж(с, скн, open);
	  если(с1>с){
	  	b--; если(b==0) возврат с1;
	  }иначе{
	  	с1+=юник8_декоде(с, скн, &юникод_символ);
	  	// s1 = is_re(s, se, open);
	  	// if(s1) b++; else s1+=utf8_decode(s, se, &ch);
	  }
	}
	// for(; rules; rules++){
	// 	s1 = ;
	// 	// printf("\ttoken %s\t%d\n", rules[ri].name, s1);
	// 	if(s1) return s1;
	// }
	возврат NULL;
}

#опред РЕ(...) { __VA_ARGS__, {0,0,0} }
регвыраж ре1[] = РЕ( {9,1,1},{32,1,3}, {10,1,0} );
регвыраж ре2[] = { {9,1,1}, {10,1,0},{9,1,1},{перв_ид,2,1},{0,0,0} };

регвыраж число_целое[] = { {цифра,2,1}, {0,0,0} };
регвыраж число_с_множ[] = { {цифра,2,1}, {'e',1,0}, {плюс_и_минус,2,2},{цифра,2,1}, {0,0,0} };

регвыраж* правила_веществ_чисел[] = {
	число_с_множ, число_целое, NULL
};

регвыраж ид[] = { {перв_и